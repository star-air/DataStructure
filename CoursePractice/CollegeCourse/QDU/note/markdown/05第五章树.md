# 第五章树


## 1. 树与二叉树的定义


### 1.1. 树的定义

- **`树型结构`**(非线性结构)
    - 结点之间有分支
    - 具有层次关系
    - 例如
        - 自然界：树
        - 人类社会：家谱、行政组织机构
        - 计算机领域：编译、数据库系统、算法分析
        
- **`树的定义`**
    - `树(Tree)`是n(n≥0)个结点的有限集
        - 若 n=0 ，称为`空树`；
        - 若 n>0 ，则它满足如下两个条件：
            - **有且仅有一个**特定的称为`根`(Root)的结点
            - **其余结点**可分为m(m≥0)个互不相交的**有限集T1、T2、T3,...,Tm**，其中每一个集合本身又是一棵树，并称为根的**子树(SubTree)**。

- **`树的其他表示方式`**
    - 嵌套集合
    - 凹入表示
    - 广义表


### 1.2. 树的基本术语

- `根结点`：非空树中无前驱结点的结点
- `叶子结点`(终端结点)：度为0的结点
- `分支结点`(非终端结点)：度不为0的结点
- `兄弟结点`：有相同双亲的同一层结点称为兄弟结点
- `堂兄弟结点`：双亲在同一层的结点
- 结点的`度`：结点拥有的子树数
- `树的度`：树内各结点的度的最大值
    - 根结点以外的分支结点称为`内部结点`
- `树的深度`：树中结点的最大层次 
- 结点的子树的根称为该结点的`孩子`，该结点称为孩子的`双亲`
- 结点的`祖先`：从根到该结点所经分支上的所有结点
- 有序树和无序树
    - 有序树：树中结点的各子树从左至右有次序(最左边的为第一个孩子)
    - 无序树：树中结点的各子树无次序
- 森林：是m(m≥0)棵互不相交的树的集合
    - 把根结点删除树就变成了森林
    - 一棵树可以看成是一个特殊的森林
    - 给森林中的各子树加上一个双亲结点，森林就变成了树
    - 树一定是森林，森林不一定是树


#### 1.2.1. 树结构和线性结构的比较

|           线性结构            |               树结构               |
| ---------------------------- | --------------------------------- |
| 第一个数据元素 `无前驱`        | 根结点(只有一个) `无双亲`            |
| 最后一个数据元素 `无后继`       | 叶子结点(可以有多个) `无孩子`        |
| 其他数据元素 `一个前驱一个后继` | 其他结点--中间结点 `一个双亲多个孩子` |
| 一对一                        | 一对多                             |

### 1.3. 二叉树的定义

> 为何要重点研究每结点最多只有两个叉的树？
> - 二叉树的结构最简单，规律性最强
> - 可以证明，所有树都能转化唯一对应的二叉树，不失一般性。

> 普通树(多叉树)若不转化二叉树，则运算很难实现？
> 二叉树在树结构的应用中起着非常重要的应用，因为对二叉树的许多操作算法简单，而任何树都可以与二叉树相互转换，这样就解决了树的存储结构及其运算中存在的复杂性。

- **`二叉树的定义`**
    - `二叉树`是n(n≥0)个结点的有限集，它或者是空集(n=0)，或者由一个**根结点**及`两棵互不相交`的分别称作这个根的**左子树**和**右子树**的二叉树组成。
    - 特点
        - 1、每个结点最多有两孩子(`二叉树中不存在度大于2的结点`)
        - 2、子树有左右之分，其次序不能颠倒
        - 3、二叉树可以是空集合，根可以有空的左子树或空的右子树。

> 注：二叉树不是树的特殊情况，它们是两种概念
> 二叉树结点的子树要`区分左子树`和`右子树`，即使只有一颗子树也要区分，是左子树和右子树
> 树当结点只有一个孩子时，就`不须区分`它是左还是右的次序。因此二者是不同的。这是二叉树和树的最主要的区别

---

> 具有三个结点的二叉树可能有几种不同形态？普通树呢？
二叉树有五种形态
树有两种形态

---



- **`二叉树的五种基本形态`**
    - 空二叉树
    - 根和空的左右子树
    - 根和左子树
    - 根和右子树
    - 根和左右子树

> 虽然二叉树和树概念不同，但是有关树的基本术语都适用于二叉树




## 2. 案例引入

> 案例5.1 数据压缩问题
> 将数据文件转换成由0、1组成的二进制串，称之为编码。

- 等长编码方案
- 不等长编码方案1
- 不等长编码方案2

> 案例5.2 利用而二叉树求解表达式的值

以二叉树表达式的递归定义如下：
- 若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息。
- 若表达式为`“第一操作数 运算符 第二操作数”`的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符(若为一元运算符，则左子树为空)，其中，操作数本身又为表达式。


## 3. 树和二叉树的抽象数据结构定义

### 3.1. 二叉树的抽象数据定义

```
ADT BinaryTree{
    数据对象D: D是具有相同特性的数据元素的集合
    数据关系R:
    基本操作P: //至少有20个
        CreateBiTree(&T,definition)
            初始条件: definition给出二叉树T的定义
            操作结果: 按definition构造二叉树T
        PreOrderTraverse(T)
            初始条件: 二叉树T存在
            操作结果: 先序遍历T,对每个结点访问一次
        InOrderTraverse(T)
            初始条件: 二叉树T存在
            操作结果: 中序遍历T,对每个结点访问一次
        PostOrderTraverse(T)
            初始条件: 二叉树T存在
            操作结果: 后序遍历T,对每个结点访问一次
            
        ...
}ADT BinaryTree
```


## 4. 二叉树的性质和存储结构

### 4.1. 二叉树性质

- **`性质1` : 在二叉树的第i层上`至多`有$2^{i-1}$个结点(i≥1)**

证明：采用归纳法证明此性质

> 第i层上至少有 (`1`) 个结点

- **`性质2` : 深度为k的二叉树`至多`有$2^k-1$个结点(k≥1)**

证明：由性质1可知，深度为k的二叉树的最大结点数为

$\sum_{i=1}^{k}(第i层上的最大结点数)=\sum_{i=1}^{k}2^{i-1}$
$=2^0+2^1+...+2^{k-1}$
$=\frac{2^0-2^{k-1}\cdot 2}{1-2}=\frac{1-2^k}{-1}$
$=2^k-1$

证毕

> 深度为k时至少有(`k`)个结点


- **`性质3` : 对任何一棵二叉树T，如果其叶子数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$**

证明：
从下往上看，每个结点都有唯一一个边，只有根结点没有
总边数为B B=n-1(n为总结点)
从上往下看，总结点分为，有两个边的结点，一个边的结点，没有边的结点，B=2n2+n1
所以$2n_2+n_1=n_0+n_1+n_2-1$
$n_0=n_2+1$


### 4.2. 两种特殊形式的二叉树

- 满二叉树
- 完全二叉树

> 为什么要研究上面两种二叉树?
因为它们在顺序存储下是可以还原的

#### 4.2.1. 满二叉树

- 一棵深度为k且有$2^k-1$个结点的二叉树称为满二叉树

- 特点
    - 1、每一层上的结点数都是最大结点数(即`每层都满`)
    - 2、叶子结点全部在最底层

- 对满二叉树结点位置进行编号
    - 编号规则：从根节点开始，`自上而下，自左而右`
    - 每一结点位置都有元素。

- 满二叉树在同样深度的二叉树中结点个数最多
- 满二叉树在同样深度的二叉树中叶子结点个数最多

#### 4.2.2. 完全二叉树

- 深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号为1~n的结点一一对应时，称之为完全二叉树。

> 注：在满二叉树中，从最后一个结点开始，`连续`去掉`任意`个结点，即是一个完全二叉树。

- 特点
    - 1、叶子只可能分布在层次最大的两层上
    - 2、对任一结点，如果其右子树的最大层次为i，则其左子树的最大层次必为i或者i+1


#### 4.2.3. 特殊二叉树性质

- **`性质4` : 具有n个结点的完全二叉树的深度为$[log_2^n]+1$**

> 注：[x]：称作x的底，表示不大于x的最大整数

`性质4`表明了完全二叉树结点数n与完全二叉树深度k之间的关系。

- `性质5` : 如果对一棵有n个结点的完全二叉树(深度$[log_2^n]+1$的结点按层序编号(从第1层到第$[log_2^n]+1$层，每层从左到右)，则对任一结点i(1≤i≤n)，有)
    - (1) 如果i=1，则结点i是二叉树的根，无双亲；如果 i > 1，则其双亲是结点$[i/2]$
    - (2) 如果2i>n，则结点i为叶子结点，无左孩子;否则，其左孩子是结点2i。
    - (3) 如果2i+1 > n，则结点i无右孩子；否则，其右孩子是结点2i+1。

`性质5表明了完全二叉树中双亲结点编号与孩子结点编号之间的关系`


### 4.3. 二叉树存储结构

#### 4.3.1. 二叉树的顺序存储

- 实现：按`满二叉树`的结点层次编号，依次存放二叉树中的数据元素。

```c
//二叉树顺序存储表示
#define MAXSIZE 100
typdef TElemType SqBiTree[MAXSIZE]
SqBiTree bt;
```

- 二叉树顺序存储特点
    - 结点间蕴含在其存储位置中
    - 浪费空间，适于存`满二叉树和完全二叉树`

#### 4.3.2. 二叉树的链式存储

- 二叉树结点
    - 数据
    - 左子树指针
    - 右子树指针
    
- 实现：二叉链表存储结构

```c
typedef struct BiNode{
    TElemType data;
    struct BiNode *Lchild,*Rchild; //左右孩子指针
}BiNode,*BiTree;
```

> 在n个结点的二叉链表中，有`n+1`个空指针域

- 三叉链表

```c
typedef struct TriTNode{
    TElemType data;
    struct TriTNode *Lchild,*parent,*Rchild;
}TriTNode,*TriTree;
```



## 5. 遍历二叉树和线索二叉树

- **`遍历定义`**-顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问依次，而且仅被访问一次(又称周游)。
    - "访问"的含义很广，可以是对结点作各种处理，如：输出结点的信息、修改结点的数据值等，但要求这种访问不破坏原来的数据结构。
- **`遍历目的`**-得到树中所有结点的一个线性排列。
- **`遍历用途`**-它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心

### 5.1. 遍历二叉树

- 遍历方法：依次遍历二叉树中的三个组成部分，便是遍历了整个二叉树
- 假设：L：遍历左子树 D：访问根结点 R：遍历右子树
- 则遍历整个二叉树方案共有：
    - DLR、LDR、LRD、DRL、RDL、RLD共六种


#### 5.1.1. 遍历二叉树算法

- 遍历二叉树算法描述：若规定**先左后右**，则只有前三种情况
    - `DLR`-先(根)序遍历
    - `LDR`-中(根)序遍历
    - `LRD`-后(根)序遍历

|                         先序遍历二叉树                         |                         中序遍历二叉树                         |                         后序遍历二叉树                         |
| ------------------------------------------------------------- | ------------------------------------------------------------- | ------------------------------------------------------------- |
| 若二叉树为空，则空操作；否则                                     | 若二叉树为空，则空操作；否则                                     | 若二叉树为空，则空操作；否则                                     |
| (1) 访问`根`结点<br>(2) `先序遍历`左子树<br>(3) `先序遍历`右子树 | (1) `中序遍历`左子树<br>(2) 访问`根`结点<br>(3) `中序遍历`右子树 | (1) `后序遍历`左子树<br>(2) `后序遍历`右子树<br>(3) 访问`根`结点 |





## 6. 树和森林

## 7. 哈夫曼树及其应用
 
## 8. 案例分析与实现