# 第四章串数组和广义表

## 1. 串的定义

- **`串(String)`**---零个或多个任意`字符组成的有限序列`
    - $S = $ " $a_1a_2...a_n$"

- **`串的几个术语`**
    - **子串**：串中任意个连续字符组成的`子序列`(或空串)称为该串的子串。
        - 例如："abcde"的子串有：”“、”a“、”ab“、  ”abc“、”abcd“、"abcde"等
        - **真子串**是指不包含本身的所有子串
    - **主串**：包含子串的串相应的称为`主串`
    - **字符位置**：字符`在序列中的序号`为该字符在串中的位置
    - **子串位置**：`子串第一个字符`在主串中的位置
    - **空格串**：由一个或多个空格组成的串，`与空串不同`
    - **串相等**：当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的。
        - 所有`空串`都是`相等`的

## 2. 案例引入

> 串的应用非常广泛，计算机上的非数值处理的对象大部分是字符串数据，例如：文字编辑、符号处理，各种信息处理系统等等。

### 2.1. 病毒感染检测

> 案例4.1 病毒感染检测
> 研究者将人的DNA和病毒的DNA均表示成由一些字母组成的字符串序列

- 然后检测某种病毒DNA序列是否在患者的DNA序列中出现过，如果出现过，则此人感染了该病毒，否则没有感染。
    - 例如：假设病毒的DNA的序列是`baa`，患者1的DNA序列为**a`aad`bbba**，则感染；患者2的DNA序列是**babbba**，则未感染
    - 注意：人的DNA序列是线性的，而病毒的DNA序列是环状的
    



## 3. 串的类型定义、存储结构及其运算

### 3.1. 串的类型定义、存储结构

```c
ADT String{
    数据对象: D={ai|ai∈CharacterSet,i=1,2,...,n,n≥0}
    数据关系: R1={<ai-1,ai>|ai-1,ai∈D,i=1,2,...,n}
    基本操作:
        StrAssign(&T,chars) //串赋值
        StrCompare(S,T) // 串比较
        StrLength(S) // 求串长
        Concat(&T,S1,S2) //串连结
        SubString(&Sub,S,pos,len) //求子串
        StrCopy(&T,S) //串拷贝
        StrEmpty(S) //串判空
        ClearString(&S) //清空串
        Index(S,T,pos) //子串的位置
        Replace(&S,T,V) //串替换
        StrInsert(&S,pos,T) //子串插入
        StrDelete(&S,pos,len) //子串删除
        DestroyString(&S) //串销毁
}ADT String
```

- 串的顺序存储结构

```c
#define MAXLEN 255
typedef struct{
    char ch[MAXLEN+1]; //存储串的一维数组
    int length;//串的当前长度
}SString;
```

- 串的链式存储结构
 
```c
#define CHUNKSIZE 80 // 块的大小可由用户定义
typedef struct Chunk{
    char ch[CHUNKSIZE];
    struct Chunk *next;
}Chunk;

typedef struct{
    Chunk *head,*tail; //串的头指针和尾指针
    int curlen; //串的当前长度
}LString;//字符串的块链结构

```

- 现实中顺序存储结构用的更多，因为现实中串很少插入和删除


### 3.2. 串的运算

#### 3.2.1. 串的模式匹配算法

- 算法目的
    - 确定主串中所含子串(模式串)第一次出现得位置(定位)

- 算法应用   
    - 搜索引擎、拼写检查、语言翻译、数据压缩
    
- 算法种类
    - BF算法(Brute-Force,又称古典的、经典的、朴素的、穷举的)
    - KMP算法 (特点：速度快)
    


#### 3.2.2. BF(Brute Force)算法

Brute-Force简称为BF算法，亦称简单匹配算法。采用穷举法的思路。
    - 主串S：正文串
    - 子串T：模式
- 算法思路是从S的每一个字符开始依次与T的字符进行匹配。


> `Index(S,T,pos)`
- 将主串的第pos个字符和模式串的第一个字符比较
    - 若相等，继续逐个比较后续字符
    - 若不等，从主串的下一字符起，重新与模式串的第一个字符比较。
- 直到主串的一个子串字符序列与模式串相等。返回值为S中与T匹配的子序列第一个字符的序号，即匹配成功。
- 否则，匹配失败，返回值0


- BF算法描述-算法4.1

```c
int Index_BF(SString S,SString T){
    int i=1;j=1;
    while(i<=S.length && j<= T.length){
        if(s.ch[i]==t.ch[j]){++i;++j;} // 主串和子串依次匹配下一个字符
        else{i=i-j+2;j=1;} // 主串、子串指针回溯重新开始下一次匹配
    }
    if(j>=T.length)return i-T.length; //返回匹配的第一个字符的下标
    else return 0;// 模式匹配不成功
}
```

- 主串前面n-m个位置都部分匹配到子串的最后一位，即这n-m位各比较了m次
- 最后m位也各比较了1次
    - 总次数为：(n-m) * m+m=(n-m+1) * m
    - 若m<<n，则算法复杂度O(n*m)


#### 3.2.3. KMP算法


> KMP算法是D.E.Knuth、J.H.Morris和V.R.Pratt共同提出的，简称KMP算法
> 该算法较BF算法有较大改进，从而使算法效率有了某种程度的提高。

- 利用已经`部分匹配`的结果而加快模式串的滑动速度
- 且主串S的指针i`不必回溯`!可提速到`O(n+m)`






## 4. 数组

### 4.1. 数组的定义和特点

- **数组**：按一定格式排列起来的，具有`相同类型`的数据元素的集合
- 一维数组 
    - **一维数组**：若线性表中的数据元素为非结构的简单元素，则称为一维数组
    - **一维数组的逻辑结构**：`线性结构`。定长的线性表。
    - **声明格式**：数据类型 变量名称[长度]
- 二维数组
    - 二维数组：若一维数组中的数据元素又是一维数组结构，则称为二维数组
    - 二维数组的逻辑结构
        - 非线性结构：每一个数据元素既在一个行表中，又在一个列表中
        - 线性结构(定长的线性表)：该线性表的每个数据元素也是一个定长的线性表。
    - 声明格式：**数据类型 变量名称[行数][列数]**
- 三维数组
    - 三维数组：若二维数组中的元素又是一个一维数组，则称作三维数组
...
- n维数组：若n-1维数组中的元素又是一个一维数组结构，则称作n维数组。

- **`结论：线性表结构是数组结构的一个特例，而数组结构又是线性表结构的扩展。`**
    - 数组特点：`结构固定`。——定义后，维数和维界不再改变。
    - 数组借本操作：除了结构的`初始化`和`销毁`之外，只有`取元素`和`修改元素值`的操作。

### 4.2. 数组的抽象类型定义

```c
ADT Array{
    数据对象: $j_i=0,...b_i-1,i=1,2,...,n$
             $D={a_{j_1j_2...j_n}|a_{j_1j_2...j_n}∈ElemSet}$
    数据关系: 略
    基本操作:
        InitArray(&A,n,bound1,...boundn) //构造数组A
        DestroyArray(&A) //销毁数组A
        Value(A,&e,index1,...,indexn) //取数组元素值
        Assign(A,&e,inde1,...,indexn) //给数组元素赋值
    
}ADT Array
```

### 4.3. 数组的顺序存储

- 因为
    - 数组特点：`结构固定`——维数和维界不变
    - 数组基本操作：初始化、销毁、取元素、修改元素(一般不插入删除)
- 所以
    - 一般都是采用`顺序存储结构`来表示数组
- `注意`：数组可以是多维的，但存储数据元素的内存单元地址是一维的，因此，在存储数组结构之前，需要解决将多维关系映射到一维关系的问题。

#### 4.3.1. 一维数组

例，有数组定义：`int a[5];`
每个元素占用4字节，假设`a[0]`存储在`2000`单元，`a[3]`地址是多少?

#### 4.3.2. 二维数组

> 连续单元是一维结构，而数组是个多维结构，则用一组连续存储单元存放数组的数据元素就有个次序约定问题

- 两种顺序存储方式
    - 以行序为主序(低下标优先) BASIC、COBOL、PASCAL、JAVA、C
    - 以列序为主序(高下标优先) FORTRAN

#### 4.3.3. 三维数组

- a[m1][m2][m3] 各维元素下数为 m1,m2,m3
- 下标为i1,i2,i3的数组元素的存储位置
    - LOC(i1,i2,i3)=a+i1 * m2 * m3 + i2 * m3 + i3
    
#### 4.3.4. n维数组






### 4.4. 特殊矩阵的压缩存储

- **矩阵**：一个由mxn个元素排成的m行n列的表
- **矩阵的常规存储**：将矩阵描述为一个二维数组
- **矩阵的常规存储的特点**：
    - 可以对其元素进行随机存取
    - 矩阵运算非常简单；存储的密度为1
- **不适宜常规存储的矩阵**：值相同的元素很多且呈某种规律分布；零元素多
- **矩阵的压缩存储**：为多个相同的非零元素只分配一个存储空间；对零元素不分配空间。

> 1. 什么是压缩存储?

若多个数据元素的值都相同，则只分配一个元素值的存储空间，且 零元素不占存储空间。

> 2. 什么样的矩阵能够压缩

一些特殊矩阵，如：对称矩阵，对角矩阵，三角矩阵，稀疏矩阵等。

> 3. 什么叫稀疏矩阵?

矩阵中非零元素的个数较少(一般少于5%)



#### 4.4.1. 对称矩阵

- 特点：在nxn的矩阵a中，满足如下性质：



#### 4.4.2. 三角矩阵


#### 4.4.3. 对角矩阵

#### 4.4.4. 稀疏矩阵



## 5. 广义表

广义表(又称列表Lists)是n≥0个元素a0，a1，...，an-1的有限序列，其中每一个ai或者是原子，或者是一个广义表。

- 例：中国举办的国际足球邀请赛，参赛队名单可表示如下：
(阿根廷，巴西，德国，法国，()，西班牙，意大利，英国，(国家队，山东鲁能，广州恒大))

- `广义表`通常记做：**LS = (a1,a2,...,an)**
    - 其中：LS为**表名**，n为**表的长度**，每一个ai为**表的元素**
- 习惯上，一般用**大写字母**表示**广义表**，**小写字母**表示**原子**
- `表头`：若LS非空(n≥1)，则其**第一个**元素a1就是表头
    - 记作head(LS)=a1 注：表头可以是原子，也可以是子表
- `表尾`：除表头外的**其它元素**组成的**表**
    - 记作tail(LS) = (a2,...,an)
    - 注：表尾不是最后一个元素，而是一个子表


### 5.1. 广义表的性质

- 广义表中的数据元素有相对`次序`；`一个直接前驱和一个直接后驱`
- 广义表的`长度`定义为最外层所包含元素的个数
    - 如：C=(a,(b,c))是长度为2的广义表
- 广义表的`深度`定义为该广义表展开后所包含括号的重数；
    - A=(b,c)的深度为1，B=(A,d)的深度为2，C=(f,B,h)的深度为3.
    - 注：”原子“的深度为0，空表的深度为1
- 广义表可以为其他广义表共享；如：广义表B就共享表A。在B中不必列出A的值，而是通过名称来引用，B=(A)
- 广义表可以是一个递归的表。如：F=(a，F)=(a，(a，(a，...)))
    - 注：递归表的深度是无穷值，长度是有限值
- 广义表是`多层次`结构，广义表的元素可以是单元素，也可以是子表，而子表的元素还可以是子表，...。
    - 可以用图形象的表达
    

### 5.2. 广义表和线性表的区别

- `广义表`可以看成是`线性表的推广`，`线性表是广义表的特例`
    - 广义表的结构相当灵活，在某种前提下，它可以兼容线性表，数组，树和有向图等各种常用的数据结构
    - 当`二维数组的每行(或每列)作为子表处理时，二维数组即为一个广义表`
    - 另外，树和有向图也可以用广义表来表示
    - 由于广义表不仅集中了线性表、数组、树和有向图等常见数据结构的特点，而且可有效地利用存储空间，因此在计算机的许多应用领域都有成功使用广义表的实例。
    

### 5.3. 广义表的基本运算

- 求表头GetHead(L)：非空广义表的第一个元素，可以是一个广义表，也可以是一个子表
- 求表尾GetTail(L)：非空广义表除去表头元素以外的其它元素所构成的表。表尾一定似乎一个表


## 6. 案例分析与实现

案例4.1：病毒感染检测

- 因为患者的DNA和病毒DNA均是由一些字母组成的字符串序列，要检测某种病毒的DNDA序列是否在患者的DNA序列中出现过，实际上就是字符串的模式匹配问题
- 可以利用BF算法，也可以利用更高效的KMP算法
- 但与一般的模式匹配问题不同的是，此案例中病毒的DNA序列是环状的
- 这样需要对传统的BF算法或KMP算法进行改进

## 7. 小结