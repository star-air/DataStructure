# 第四讲图

## 1.图的定义

### 1.1 什么是图

- 表示”多对多”的关系
- 包含
  - 一组顶点：通常用 `V（Vertex）`表示顶点集合
  - 一组边：通常用 `E（Edge）`表示边的集合
    - 边是顶点对：`（v,w）∈ E`，其中 v,w ∈ V   `v-w`
    - 有向边 `<v,w>` 表示从 v 指向 w 的边（`单行线`） `v→w`
    - 不考虑重边和自回路


### 1.2 常见术语

- 无向图：图中所有的边无所谓方向
- 有向图：图中的边可能是双向，也可能是单向的，方向是很重要的
- 权值：给图中每条边赋予的值，可能有各种各样的现实意义
- 网络：带权值的图
- 邻接点：有边直接相连的顶点
- 出度：从某顶点发出的边数
- 入度：指向某顶点的边数
- 稀疏图：顶点很多而边很少的图
- 稠密图：顶点多边也多的图
- 完全图：对于给定的一组顶点，顶点间都存在边


### 1.3 抽象数据类型定义

- 类型名称：图（Graph）

- 数据对象集：G（V，E）由一个非空的有限顶点集合 V 和一个有限边集合 E 组成

- 操作集：对于任意图 G ∈ Graph，以及 v ∈ V，e ∈ E

- 主要操作有：
  - `Graph Crate()`：建立并返回空图
  - `Graph InsertVertex(Graph G,Vertex v)`：将 v 插入 G
  - `Graph InsertEdge(Graph G,Edge e)`：将 e 插入 G
  - `void DFS(Graph G,Vertex v)`：从顶点 v 出发深度优先遍历图 G
  - `void BFS(Graph G,Vertex v)`：从顶点 v 出发宽度优先遍历图 G

### 1.4 图的表示

#### 1 邻接矩阵表示法

- 邻接矩阵$G[N][N]$-N个顶点(编号0 - N-1)
  $G[i][j]=\begin{cases}0& \text{若<V_i,V_j>是G中的边}\\1& \text{否则}\end{cases}$

![邻接矩阵](https://cdn.jsdelivr.net/gh/Star-air/picstorage@master/数据结构笔记/4-1.png)

- 特征：
  - 对角线元素全 0
  - 关于对角线对称

- 优点：
  - 直观、简单、好理解
  - 方便检查任意一对顶点间是否存在边
  - 方便找任一顶点的所有邻接点
  - 方便计算任一顶点的度
    - 无向图：对应行（或列）非 0 元素的个数
    - 有向图：对应行非 0 元素的个数是出度；对应列非 0 元素的个数是入度

- 缺点：
  - 浪费空间——存稀疏图
  - 浪费时间——统计稀疏图的边



#### 2 邻接表表示法

邻接表：G[N] 为指针数组，对应矩阵每行一个链表，只存非 0 元素

![邻接表](https://cdn.jsdelivr.net/gh/Star-air/picstorage@master/数据结构笔记/4-2.png)

- 特点：
  - 方便找任一顶点的所有邻接顶点
  - 节省稀疏图的空间
    - 需要 N 个头指针 + 2E 个结点（每个结点至少 2 个域）
  - 对于是否方便计算任一顶点的度
    - 无向图：方便
    - 有向图：只能计算出度
  - 不方便检查任意一对顶点间是否存在边



## 2.图的遍历

### 2.1 DFS（深度优先搜索）

深度优先搜索（Depth First Search)，类似于树的先序遍历
```c
void DFS ( Vertex V ){
    visited[ V ] = true;
    for ( V 的每个邻接点 W )
        if( !visited[ W ])
            DFS( W );
}
```
若有 N 个顶点、E 条边，时间复杂度是
  - 用邻接表存储，$O(N+E)$
  - 用邻接矩阵存储，$O(N^2​​)$


### 2.2 BFS（广度优先搜索）

广度优先搜索（Breadth First Search)，相当于树的层序遍历
```c
void BFS( Vertex V ){
    queue<Vertex> q;
    visited[V] = true;
    q.push(V);
    while(!q.empty()){
        V = q.front(); q.pop();
        for( V 的每个邻接点 W ){
        	if( !visited[ W ]){
            	visited[W] = true;
            	q.push(W);
            }
        }
    }
}
```
若有 N 个顶点、E 条边，时间复杂度是
  - 用邻接表存储，$O(N+E)$
  - 用邻接矩阵存储，$O(N^2​​)$


## 3.最短路径

## 4.最小生成树

## ⭐课后编程习题1